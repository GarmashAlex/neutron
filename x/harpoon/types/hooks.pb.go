// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: neutron/harpoon/hooks.proto

package types

import (
	fmt "fmt"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Hook types that can be subscribed to.
type HookType int32

const (
	// Triggered after validator is created
	HookType_AfterValidatorCreated HookType = 0
	// Triggered before validator is modified
	HookType_BeforeValidatorModified HookType = 1
	// Triggered after validator is removed
	HookType_AfterValidatorRemoved HookType = 2
	// Triggered after validator is bonded
	HookType_AfterValidatorBonded HookType = 3
	// Triggered after validator begins unbonding
	HookType_AfterValidatorBeginUnbonding HookType = 4
	// Triggered before delegation is created
	HookType_BeforeDelegationCreated HookType = 5
	// Triggered before delegation's shares are modified
	HookType_BeforeDelegationSharesModified HookType = 6
	// Triggered before delegation is removed
	HookType_BeforeDelegationRemoved HookType = 7
	// Triggered after delegation is modified
	HookType_AfterDelegationModified HookType = 8
	// Triggered before validator is slashed
	HookType_BeforeValidatorSlashed HookType = 9
	// Triggered after unbonding is initiated
	HookType_AfterUnbondingInitiated HookType = 10
)

var HookType_name = map[int32]string{
	0:  "AfterValidatorCreated",
	1:  "BeforeValidatorModified",
	2:  "AfterValidatorRemoved",
	3:  "AfterValidatorBonded",
	4:  "AfterValidatorBeginUnbonding",
	5:  "BeforeDelegationCreated",
	6:  "BeforeDelegationSharesModified",
	7:  "BeforeDelegationRemoved",
	8:  "AfterDelegationModified",
	9:  "BeforeValidatorSlashed",
	10: "AfterUnbondingInitiated",
}

var HookType_value = map[string]int32{
	"AfterValidatorCreated":          0,
	"BeforeValidatorModified":        1,
	"AfterValidatorRemoved":          2,
	"AfterValidatorBonded":           3,
	"AfterValidatorBeginUnbonding":   4,
	"BeforeDelegationCreated":        5,
	"BeforeDelegationSharesModified": 6,
	"BeforeDelegationRemoved":        7,
	"AfterDelegationModified":        8,
	"BeforeValidatorSlashed":         9,
	"AfterUnbondingInitiated":        10,
}

func (x HookType) String() string {
	return proto.EnumName(HookType_name, int32(x))
}

func (HookType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a137ba09c56f7009, []int{0}
}

// Specifies how subscribed contract_addresses are stored in the KV store for each hook type.
type HookSubscriptions struct {
	// The hook type being subscribed to.
	HookType HookType `protobuf:"varint,1,opt,name=hookType,proto3,enum=neutron.harpoon.HookType" json:"hookType,omitempty"`
	// Contract addresses subscribed to this hook type.
	ContractAddresses []string `protobuf:"bytes,2,rep,name=contract_addresses,json=contractAddresses,proto3" json:"contract_addresses,omitempty"`
}

func (m *HookSubscriptions) Reset()         { *m = HookSubscriptions{} }
func (m *HookSubscriptions) String() string { return proto.CompactTextString(m) }
func (*HookSubscriptions) ProtoMessage()    {}
func (*HookSubscriptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_a137ba09c56f7009, []int{0}
}
func (m *HookSubscriptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HookSubscriptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HookSubscriptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HookSubscriptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HookSubscriptions.Merge(m, src)
}
func (m *HookSubscriptions) XXX_Size() int {
	return m.Size()
}
func (m *HookSubscriptions) XXX_DiscardUnknown() {
	xxx_messageInfo_HookSubscriptions.DiscardUnknown(m)
}

var xxx_messageInfo_HookSubscriptions proto.InternalMessageInfo

func (m *HookSubscriptions) GetHookType() HookType {
	if m != nil {
		return m.HookType
	}
	return HookType_AfterValidatorCreated
}

func (m *HookSubscriptions) GetContractAddresses() []string {
	if m != nil {
		return m.ContractAddresses
	}
	return nil
}

func init() {
	proto.RegisterEnum("neutron.harpoon.HookType", HookType_name, HookType_value)
	proto.RegisterType((*HookSubscriptions)(nil), "neutron.harpoon.HookSubscriptions")
}

func init() { proto.RegisterFile("neutron/harpoon/hooks.proto", fileDescriptor_a137ba09c56f7009) }

var fileDescriptor_a137ba09c56f7009 = []byte{
	// 366 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x6c, 0x92, 0xcf, 0x6e, 0xda, 0x40,
	0x10, 0x87, 0x6d, 0x68, 0x29, 0xec, 0xa1, 0x35, 0xab, 0xfe, 0x81, 0x52, 0x59, 0x88, 0x13, 0xaa,
	0x84, 0xad, 0xb6, 0xe2, 0x01, 0xa0, 0x3d, 0x50, 0x45, 0xb9, 0x40, 0x92, 0x43, 0x2e, 0xd1, 0xda,
	0x3b, 0xd8, 0x2b, 0x60, 0xc7, 0xda, 0x5d, 0x50, 0x78, 0x8b, 0x3c, 0x56, 0x2e, 0x91, 0x38, 0xe6,
	0x18, 0xc1, 0x8b, 0x44, 0x46, 0xb6, 0x51, 0x9c, 0x9c, 0x6c, 0xe9, 0x9b, 0xdf, 0xcc, 0xb7, 0xbb,
	0x43, 0x3a, 0x12, 0xd6, 0x46, 0xa1, 0xf4, 0x63, 0xa6, 0x12, 0x4c, 0xbf, 0x88, 0x0b, 0xed, 0x25,
	0x0a, 0x0d, 0xd2, 0x4f, 0x19, 0xf4, 0x32, 0xd8, 0xdb, 0x92, 0xe6, 0x04, 0x71, 0x31, 0x5b, 0x07,
	0x3a, 0x54, 0x22, 0x31, 0x02, 0xa5, 0xa6, 0x43, 0x52, 0x4f, 0x43, 0x17, 0xdb, 0x04, 0x5a, 0x76,
	0xd7, 0xee, 0x7f, 0xfc, 0xdd, 0xf6, 0x4a, 0x41, 0x6f, 0x92, 0x15, 0x4c, 0x8b, 0x52, 0x3a, 0x20,
	0x34, 0x44, 0x69, 0x14, 0x0b, 0xcd, 0x0d, 0xe3, 0x5c, 0x81, 0xd6, 0xa0, 0x5b, 0x95, 0x6e, 0xb5,
	0xdf, 0x98, 0x36, 0x73, 0x32, 0xca, 0xc1, 0xcf, 0x87, 0x0a, 0xa9, 0xe7, 0x5d, 0x68, 0x9b, 0x7c,
	0x19, 0xcd, 0x0d, 0xa8, 0x2b, 0xb6, 0x14, 0x9c, 0x19, 0x54, 0x7f, 0x15, 0x30, 0x03, 0xdc, 0xb1,
	0x68, 0x87, 0x7c, 0x1b, 0xc3, 0x1c, 0x15, 0x14, 0xec, 0x1c, 0xb9, 0x98, 0x0b, 0xe0, 0x8e, 0xfd,
	0x3a, 0x37, 0x85, 0x15, 0x6e, 0x80, 0x3b, 0x15, 0xda, 0x22, 0x9f, 0x5f, 0xa2, 0x31, 0x4a, 0x0e,
	0xdc, 0xa9, 0xd2, 0x2e, 0xf9, 0x51, 0x22, 0x10, 0x09, 0x79, 0x29, 0x03, 0x94, 0x5c, 0xc8, 0xc8,
	0x79, 0x77, 0x9a, 0xf9, 0x0f, 0x96, 0x10, 0xb1, 0xf4, 0x5a, 0x72, 0xa1, 0xf7, 0xb4, 0x47, 0xdc,
	0x32, 0x9c, 0xc5, 0x4c, 0x81, 0x2e, 0xbc, 0x6a, 0x6f, 0x35, 0xc8, 0xcd, 0x3e, 0xa4, 0xf0, 0x38,
	0xff, 0xc4, 0x8a, 0x64, 0x9d, 0x7e, 0x27, 0x5f, 0x4b, 0xc7, 0x9d, 0x2d, 0x99, 0x8e, 0x81, 0x3b,
	0x8d, 0x22, 0x58, 0xa8, 0xfe, 0x97, 0xc2, 0x88, 0xa3, 0x16, 0x19, 0x9f, 0xdd, 0xef, 0x5d, 0x7b,
	0xb7, 0x77, 0xed, 0xa7, 0xbd, 0x6b, 0xdf, 0x1d, 0x5c, 0x6b, 0x77, 0x70, 0xad, 0xc7, 0x83, 0x6b,
	0x5d, 0xff, 0x8a, 0x84, 0x89, 0xd7, 0x81, 0x17, 0xe2, 0xca, 0xcf, 0xde, 0x71, 0x80, 0x2a, 0xca,
	0xff, 0xfd, 0xcd, 0xd0, 0xbf, 0x2d, 0xd6, 0xc5, 0x6c, 0x13, 0xd0, 0x41, 0xed, 0xb8, 0x2f, 0x7f,
	0x9e, 0x03, 0x00, 0x00, 0xff, 0xff, 0x80, 0x60, 0xe1, 0xcb, 0x4e, 0x02, 0x00, 0x00,
}

func (m *HookSubscriptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HookSubscriptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HookSubscriptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContractAddresses) > 0 {
		for iNdEx := len(m.ContractAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ContractAddresses[iNdEx])
			copy(dAtA[i:], m.ContractAddresses[iNdEx])
			i = encodeVarintHooks(dAtA, i, uint64(len(m.ContractAddresses[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.HookType != 0 {
		i = encodeVarintHooks(dAtA, i, uint64(m.HookType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintHooks(dAtA []byte, offset int, v uint64) int {
	offset -= sovHooks(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HookSubscriptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HookType != 0 {
		n += 1 + sovHooks(uint64(m.HookType))
	}
	if len(m.ContractAddresses) > 0 {
		for _, s := range m.ContractAddresses {
			l = len(s)
			n += 1 + l + sovHooks(uint64(l))
		}
	}
	return n
}

func sovHooks(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozHooks(x uint64) (n int) {
	return sovHooks(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HookSubscriptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHooks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HookSubscriptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HookSubscriptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HookType", wireType)
			}
			m.HookType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HookType |= HookType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHooks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddresses = append(m.ContractAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHooks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHooks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHooks(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHooks
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHooks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHooks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthHooks
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupHooks
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthHooks
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthHooks        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHooks          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupHooks = fmt.Errorf("proto: unexpected end of group")
)
