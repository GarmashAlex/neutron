// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: neutron/harpoon/hooks.proto

package types

import (
	fmt "fmt"
	_ "github.com/cosmos/gogoproto/gogoproto"
	proto "github.com/cosmos/gogoproto/proto"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

// Hook types that can be subscribed to.
type HookType int32

const (
	// Triggered after validator is created
	HOOK_TYPE_AFTER_VALIDATOR_CREATED HookType = 0
	// Triggered before validator is modified
	HOOK_TYPE_BEFORE_VALIDATOR_MODIFIED HookType = 1
	// Triggered after validator is removed
	HOOK_TYPE_AFTER_VALIDATOR_REMOVED HookType = 2
	// Triggered after validator is bonded
	HOOK_TYPE_AFTER_VALIDATOR_BONDED HookType = 3
	// Triggered after validator begins unbonding
	HOOK_TYPE_AFTER_VALIDATOR_BEGIN_UNBONDING HookType = 4
	// Triggered before delegation is created
	HOOK_TYPE_BEFORE_DELEGATION_CREATED HookType = 5
	// Triggered before delegation's shares are modified
	HOOK_TYPE_BEFORE_DELEGATION_SHARES_MODIFIED HookType = 6
	// Triggered before delegation is removed
	HOOK_TYPE_BEFORE_DELEGATION_REMOVED HookType = 7
	// Triggered after delegation is modified
	HOOK_TYPE_AFTER_DELEGATION_MODIFIED HookType = 8
	// Triggered before validator is slashed
	HOOK_TYPE_BEFORE_VALIDATOR_SLASHED HookType = 9
	// Triggered after unbonding is initiated
	HOOK_TYPE_AFTER_UNBONDING_INITIATED HookType = 10
)

var HookType_name = map[int32]string{
	0:  "HOOK_TYPE_AFTER_VALIDATOR_CREATED",
	1:  "HOOK_TYPE_BEFORE_VALIDATOR_MODIFIED",
	2:  "HOOK_TYPE_AFTER_VALIDATOR_REMOVED",
	3:  "HOOK_TYPE_AFTER_VALIDATOR_BONDED",
	4:  "HOOK_TYPE_AFTER_VALIDATOR_BEGIN_UNBONDING",
	5:  "HOOK_TYPE_BEFORE_DELEGATION_CREATED",
	6:  "HOOK_TYPE_BEFORE_DELEGATION_SHARES_MODIFIED",
	7:  "HOOK_TYPE_BEFORE_DELEGATION_REMOVED",
	8:  "HOOK_TYPE_AFTER_DELEGATION_MODIFIED",
	9:  "HOOK_TYPE_BEFORE_VALIDATOR_SLASHED",
	10: "HOOK_TYPE_AFTER_UNBONDING_INITIATED",
}

var HookType_value = map[string]int32{
	"HOOK_TYPE_AFTER_VALIDATOR_CREATED":           0,
	"HOOK_TYPE_BEFORE_VALIDATOR_MODIFIED":         1,
	"HOOK_TYPE_AFTER_VALIDATOR_REMOVED":           2,
	"HOOK_TYPE_AFTER_VALIDATOR_BONDED":            3,
	"HOOK_TYPE_AFTER_VALIDATOR_BEGIN_UNBONDING":   4,
	"HOOK_TYPE_BEFORE_DELEGATION_CREATED":         5,
	"HOOK_TYPE_BEFORE_DELEGATION_SHARES_MODIFIED": 6,
	"HOOK_TYPE_BEFORE_DELEGATION_REMOVED":         7,
	"HOOK_TYPE_AFTER_DELEGATION_MODIFIED":         8,
	"HOOK_TYPE_BEFORE_VALIDATOR_SLASHED":          9,
	"HOOK_TYPE_AFTER_UNBONDING_INITIATED":         10,
}

func (x HookType) String() string {
	return proto.EnumName(HookType_name, int32(x))
}

func (HookType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a137ba09c56f7009, []int{0}
}

// Specifies how subscribed contract_addresses are stored in the KV store for each hook type.
type HookSubscriptions struct {
	// The hook type being subscribed to.
	HookType HookType `protobuf:"varint,1,opt,name=hook_type,json=hookType,proto3,enum=neutron.harpoon.HookType" json:"hook_type,omitempty"`
	// Contract addresses subscribed to this hook type.
	ContractAddresses []string `protobuf:"bytes,2,rep,name=contract_addresses,json=contractAddresses,proto3" json:"contract_addresses,omitempty"`
}

func (m *HookSubscriptions) Reset()         { *m = HookSubscriptions{} }
func (m *HookSubscriptions) String() string { return proto.CompactTextString(m) }
func (*HookSubscriptions) ProtoMessage()    {}
func (*HookSubscriptions) Descriptor() ([]byte, []int) {
	return fileDescriptor_a137ba09c56f7009, []int{0}
}
func (m *HookSubscriptions) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *HookSubscriptions) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_HookSubscriptions.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *HookSubscriptions) XXX_Merge(src proto.Message) {
	xxx_messageInfo_HookSubscriptions.Merge(m, src)
}
func (m *HookSubscriptions) XXX_Size() int {
	return m.Size()
}
func (m *HookSubscriptions) XXX_DiscardUnknown() {
	xxx_messageInfo_HookSubscriptions.DiscardUnknown(m)
}

var xxx_messageInfo_HookSubscriptions proto.InternalMessageInfo

func (m *HookSubscriptions) GetHookType() HookType {
	if m != nil {
		return m.HookType
	}
	return HOOK_TYPE_AFTER_VALIDATOR_CREATED
}

func (m *HookSubscriptions) GetContractAddresses() []string {
	if m != nil {
		return m.ContractAddresses
	}
	return nil
}

func init() {
	proto.RegisterEnum("neutron.harpoon.HookType", HookType_name, HookType_value)
	proto.RegisterType((*HookSubscriptions)(nil), "neutron.harpoon.HookSubscriptions")
}

func init() { proto.RegisterFile("neutron/harpoon/hooks.proto", fileDescriptor_a137ba09c56f7009) }

var fileDescriptor_a137ba09c56f7009 = []byte{
	// 418 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x92, 0x4f, 0x8f, 0xd2, 0x40,
	0x18, 0xc6, 0xdb, 0x65, 0x5d, 0x61, 0x0e, 0xda, 0x9d, 0x78, 0x58, 0xd7, 0xa4, 0xc1, 0xf5, 0xdf,
	0xaa, 0xa1, 0x8d, 0x1a, 0xbd, 0x0f, 0xce, 0x40, 0x27, 0x0b, 0x1d, 0x33, 0xad, 0x24, 0x7a, 0x99,
	0x40, 0x69, 0x0a, 0x21, 0x76, 0x9a, 0xb6, 0x18, 0xf1, 0x13, 0x78, 0xf4, 0x3b, 0xf8, 0x65, 0x3c,
	0x72, 0xd4, 0x9b, 0x81, 0x2f, 0x62, 0x0a, 0x6d, 0x41, 0x83, 0xf5, 0xd4, 0x37, 0x79, 0x7e, 0xfd,
	0xe5, 0x7d, 0x26, 0x2f, 0xb8, 0x13, 0xfa, 0xf3, 0x34, 0x96, 0xa1, 0x39, 0x19, 0xc6, 0x91, 0xcc,
	0xbe, 0x52, 0xce, 0x12, 0x23, 0x8a, 0x65, 0x2a, 0xe1, 0xcd, 0x3c, 0x34, 0xf2, 0xf0, 0xfc, 0x56,
	0x20, 0x03, 0xb9, 0xc9, 0xcc, 0x6c, 0xda, 0x62, 0x17, 0x9f, 0xc1, 0xa9, 0x25, 0xe5, 0xcc, 0x99,
	0x8f, 0x12, 0x2f, 0x9e, 0x46, 0xe9, 0x54, 0x86, 0x09, 0x7c, 0x05, 0x1a, 0x99, 0x4a, 0xa4, 0x8b,
	0xc8, 0x3f, 0x53, 0x9b, 0xea, 0xe5, 0x8d, 0xe7, 0xb7, 0x8d, 0xbf, 0x7c, 0x46, 0xf6, 0x9b, 0xbb,
	0x88, 0x7c, 0x5e, 0x9f, 0xe4, 0x13, 0x6c, 0x01, 0xe8, 0xc9, 0x30, 0x8d, 0x87, 0x5e, 0x2a, 0x86,
	0xe3, 0x71, 0xec, 0x27, 0x89, 0x9f, 0x9c, 0x1d, 0x35, 0x6b, 0x97, 0x0d, 0x7e, 0x5a, 0x24, 0xa8,
	0x08, 0x9e, 0xfc, 0xac, 0x81, 0x7a, 0x61, 0x81, 0x0f, 0xc0, 0x5d, 0x8b, 0xb1, 0x2b, 0xe1, 0xbe,
	0x7b, 0x43, 0x04, 0xea, 0xb8, 0x84, 0x8b, 0x01, 0xea, 0x51, 0x8c, 0x5c, 0xc6, 0xc5, 0x6b, 0x4e,
	0x90, 0x4b, 0xb0, 0xa6, 0xc0, 0x47, 0xe0, 0xde, 0x0e, 0x6b, 0x93, 0x0e, 0xe3, 0x64, 0x8f, 0xeb,
	0x33, 0x4c, 0x3b, 0x94, 0x60, 0x4d, 0xad, 0xf6, 0x71, 0xd2, 0x67, 0x03, 0x82, 0xb5, 0x23, 0x78,
	0x1f, 0x34, 0xff, 0x8d, 0xb5, 0x99, 0x8d, 0x09, 0xd6, 0x6a, 0xb0, 0x05, 0x1e, 0x57, 0x50, 0xa4,
	0x4b, 0x6d, 0xf1, 0xd6, 0xce, 0x68, 0x6a, 0x77, 0xb5, 0xe3, 0x83, 0x4b, 0x62, 0xd2, 0x23, 0x5d,
	0xe4, 0x52, 0x66, 0x97, 0x6d, 0xae, 0x41, 0x13, 0x3c, 0xad, 0x02, 0x1d, 0x0b, 0x71, 0xe2, 0xec,
	0x5a, 0x9d, 0xfc, 0xcf, 0x5c, 0xf4, 0xba, 0xfe, 0x27, 0xb8, 0xdd, 0x78, 0x8f, 0x2b, 0x8d, 0x75,
	0xf8, 0x10, 0x5c, 0x54, 0x3c, 0xa8, 0xd3, 0x43, 0x8e, 0x45, 0xb0, 0xd6, 0x38, 0x24, 0x2c, 0x2b,
	0x0b, 0x6a, 0x53, 0x97, 0x6e, 0x3a, 0x81, 0xf3, 0xe3, 0x2f, 0xdf, 0x74, 0xa5, 0x7d, 0xf5, 0x7d,
	0xa5, 0xab, 0xcb, 0x95, 0xae, 0xfe, 0x5a, 0xe9, 0xea, 0xd7, 0xb5, 0xae, 0x2c, 0xd7, 0xba, 0xf2,
	0x63, 0xad, 0x2b, 0xef, 0x9f, 0x05, 0xd3, 0x74, 0x32, 0x1f, 0x19, 0x9e, 0xfc, 0x60, 0xe6, 0x37,
	0xd5, 0x92, 0x71, 0x50, 0xcc, 0xe6, 0xc7, 0x97, 0xe6, 0xa7, 0xf2, 0xa2, 0xb3, 0x0b, 0x4c, 0x46,
	0x27, 0x9b, 0x5b, 0x7d, 0xf1, 0x3b, 0x00, 0x00, 0xff, 0xff, 0x69, 0xd4, 0x14, 0xcb, 0xf1, 0x02,
	0x00, 0x00,
}

func (m *HookSubscriptions) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *HookSubscriptions) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *HookSubscriptions) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if len(m.ContractAddresses) > 0 {
		for iNdEx := len(m.ContractAddresses) - 1; iNdEx >= 0; iNdEx-- {
			i -= len(m.ContractAddresses[iNdEx])
			copy(dAtA[i:], m.ContractAddresses[iNdEx])
			i = encodeVarintHooks(dAtA, i, uint64(len(m.ContractAddresses[iNdEx])))
			i--
			dAtA[i] = 0x12
		}
	}
	if m.HookType != 0 {
		i = encodeVarintHooks(dAtA, i, uint64(m.HookType))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func encodeVarintHooks(dAtA []byte, offset int, v uint64) int {
	offset -= sovHooks(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *HookSubscriptions) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.HookType != 0 {
		n += 1 + sovHooks(uint64(m.HookType))
	}
	if len(m.ContractAddresses) > 0 {
		for _, s := range m.ContractAddresses {
			l = len(s)
			n += 1 + l + sovHooks(uint64(l))
		}
	}
	return n
}

func sovHooks(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozHooks(x uint64) (n int) {
	return sovHooks(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *HookSubscriptions) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowHooks
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: HookSubscriptions: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: HookSubscriptions: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field HookType", wireType)
			}
			m.HookType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.HookType |= HookType(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ContractAddresses", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowHooks
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthHooks
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthHooks
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ContractAddresses = append(m.ContractAddresses, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipHooks(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthHooks
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipHooks(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowHooks
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHooks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowHooks
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthHooks
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupHooks
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthHooks
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthHooks        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowHooks          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupHooks = fmt.Errorf("proto: unexpected end of group")
)
